<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>SidecarTridge Products Firmware Installer</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Space+Grotesk:wght@500&display=swap" rel="stylesheet">
<style>
body {
  font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  background: #0b0f17;
  color: #e5e7eb;
  padding: 20px;
}

#app {
  width: 100%;
  max-width: 1080px;
  margin: 0 auto;
}

#browserWarning {
  width: 100%;
  max-width: 1080px;
  margin: 0 auto 16px;
}

.top-banner {
  width: 100%;
  max-width: 1080px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0.35rem 0.75rem;
  border: 1px solid rgba(15, 18, 28, 0.12);
  border-radius: 16px;
  background: rgba(245, 246, 250, 0.92);
  box-shadow: 0 12px 26px rgba(0, 0, 0, 0.12);
  backdrop-filter: blur(6px);
  margin: 0 auto 16px;
}

.brand-link {
  display: inline-flex;
  align-items: center;
  gap: 0.65rem;
  color: #11131a;
  text-decoration: none;
}

.brand-link img {
  display: block;
}

.brand-mark {
  width: 42px;
  height: 42px;
}

.brand-wordmark {
  height: 24px;
  width: auto;
}

.back-link {
  display: inline-flex;
  align-items: center;
  gap: 0.4rem;
  font-size: 0.9rem;
  letter-spacing: 0.05em;
  text-transform: uppercase;
  color: #1b2435;
  text-decoration: none;
  padding: 0.55rem 1rem;
  border-radius: 999px;
  border: 1px solid rgba(27, 33, 48, 0.22);
  background: rgba(229, 233, 244, 0.85);
  transition: border-color 0.2s ease, background 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease, color 0.2s ease;
}

.back-link:hover {
  border-color: rgba(27, 33, 48, 0.42);
  background: rgba(255, 255, 255, 0.95);
  color: #0b0f18;
  transform: translateY(-1px);
  box-shadow: 0 10px 20px rgba(15, 18, 28, 0.18);
}

button {
  padding: 8px 14px;
  border-radius: 6px;
  border: none;
  background: #f97316;
  font-weight: 600;
  color: #0b0f17;
}

button:disabled {
  opacity: .5;
}

button.state-not-connected {
  background: #1f2937;
  color: #f9fafb;
  border: 1px solid #374151;
}

button.state-needs-access {
  background: #fde047;
  color: #111827;
}

button.state-writing {
  background: #22c55e;
  color: #052e16;
}

.steps {
  margin: 0 0 14px;
  padding: 0;
  list-style: none;
}

.step {
  border: 1px solid #1f2937;
  border-radius: 6px;
  background: #0f172a;
  margin-bottom: 8px;
  overflow: hidden;
}

.family-card {
  display: grid;
  grid-template-columns: 220px 1fr;
  gap: 12px;
  align-items: center;
  padding: 10px;
  border: 1px solid #1f2937;
  border-radius: 6px;
  background: #0b1220;
  color: #cbd5f5;
}

.family-card img {
  width: 220px;
  height: 220px;
  object-fit: contain;
  padding: 6px;
  border-radius: 4px;
  border: 1px solid #1f2937;
  background: #0b0f17;
}

.family-card h4 {
  margin: 0 0 4px;
  color: #e5e7eb;
}

.step-header {
  display: flex;
  justify-content: space-between;
  gap: 12px;
  padding: 10px 12px;
  font-weight: 600;
  color: #e5e7eb;
}

.step-header span {
  color: #94a3b8;
  font-weight: 500;
}

.step-content {
  max-height: 0;
  opacity: 0;
  padding: 0 12px;
  color: #cbd5f5;
  transition: max-height 0.25s ease, opacity 0.25s ease, padding 0.25s ease;
}

.step.active .step-content {
  max-height: 480px;
  opacity: 1;
  padding: 8px 12px 12px;
}

.step.complete .step-header {
  color: #86efac;
}

pre {
  background: #111827;
  padding: 10px;
  border-radius: 6px;
  height: 220px;
  overflow: auto;
}

progress {
  width: 100%;
  height: 18px;
  appearance: none;
  border-radius: 999px;
  background: rgba(148, 163, 184, 0.25);
  overflow: hidden;
}

progress::-webkit-progress-bar {
  background: transparent;
}

progress::-webkit-progress-value {
  background: #3b82f6;
}

progress::-moz-progress-bar {
  background: #3b82f6;
}

progress.progress-load::-webkit-progress-value {
  background: #3b82f6;
}

progress.progress-load::-moz-progress-bar {
  background: #3b82f6;
}

progress.progress-erase::-webkit-progress-value {
  background: #ef4444;
}

progress.progress-erase::-moz-progress-bar {
  background: #ef4444;
}

progress.progress-write::-webkit-progress-value {
  background: #22c55e;
}

progress.progress-write::-moz-progress-bar {
  background: #22c55e;
}

progress.progress-verify::-webkit-progress-value {
  background: #06b6d4;
}

progress.progress-verify::-moz-progress-bar {
  background: #06b6d4;
}

.progress-wrap {
  position: relative;
  width: 100%;
}

.progress-label {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.85rem;
  font-weight: 600;
  color: #e5e7eb;
  pointer-events: none;
  text-shadow: 0 1px 2px rgba(0,0,0,0.6);
}
</style>
</head>

<body>

<nav class="top-banner">
  <a class="brand-link" href="https://sidecartridge.com" target="_blank" rel="noopener">
    <img class="brand-mark" src="https://sidecartridge.com/assets/images/logo/logo.png" alt="SidecarTridge logo mark">
    <img class="brand-wordmark" src="https://sidecartridge.com/assets/images/logo/logo-text.png" alt="SidecarTridge">
  </a>
  <a href="#" id="backLink" class="back-link">&#8592; Back</a>
</nav>

<div id="browserWarning" style="display:none; padding:12px; background:#7f1d1d; border-radius:6px; margin-bottom:16px;">
  Web flashing is not supported in this browser. Please use the manual BOOTSEL procedure and download the firmware instead.
</div>

<div id="app">
  <h2>SidecarTridge Products Firmware Installer</h2>
  <p style="margin-top:6px; color:#cbd5f5;">
    This page helps you install firmware on your device safely. Select your device family and firmware,
    then follow the steps to load and install it. No extra apps are needed.
  </p>

  <ul class="steps" id="steps">
    <li id="step1" class="step active">
      <div class="step-header">Step 1/4 <span>Ready</span></div>
      <div class="step-content">
        <div style="margin-bottom:8px;">Put your board in BOOTSEL mode (using the BOOTSEL or BOOT button), then click <strong>Detect MCU</strong>.</div>
        <div style="margin-bottom:8px; color:#cbd5f5;">
          1) Unplug the board from USB.<br>
          2) Press and hold the <strong>BOOTSEL or BOOT</strong> button on the board.<br>
          3) While holding BOOTSEL or BOOT, plug the USB cable back in.<br>
          4) Release BOOTSEL or BOOT after 1-2 seconds.
        </div>
        <div style="margin-bottom:8px; color:#93c5fd;">
          Tip: In BOOTSEL mode, many boards appear as a USB drive named <strong>RPI-RP2</strong> (RP2040) or <strong>RP2350</strong>.
        </div>
        <button id="detectMcu" class="secondary" type="button">Detect MCU</button>
        <div id="mcuDetected" style="margin-top:8px; color:#cbd5f5;">MCU: (not detected)</div>
      </div>
    </li>
    <li id="step2" class="step">
      <div class="step-header">Step 2/4 <span>Pending</span></div>
      <div class="step-content">
        <div style="margin-bottom:8px;">Select the device family and firmware filtered by detected MCU.</div>
        <div style="display:grid; gap:8px;">
          <label>
            Family<br>
            <select id="familySelect" style="width:100%; padding:6px;" disabled>
              <option value="">Detect MCU first</option>
            </select>
          </label>
          <div id="familyDetails" class="family-card" style="display:none;">
            <img id="familyImage" alt="Family image">
            <div>
              <h4 id="familyName">Family</h4>
              <div id="familyDescription"></div>
            </div>
          </div>
          <label>
            Firmware<br>
            <select id="firmwareSelect" style="width:100%; padding:6px;" disabled>
              <option value="">Select a family first</option>
            </select>
          </label>
          <div id="firmwareDetails" style="padding:8px; border:1px solid #1f2937; border-radius:6px; background:#0b1220; color:#cbd5f5;">
            Select a firmware to see details.
          </div>
          <div id="manualNotice" style="display:none; padding:8px; border:1px solid #7f1d1d; border-radius:6px; background:#1f2937; color:#fca5a5;">
            Please follow the manual BOOTSEL or BOOT button instructions in the quickstart guide:
            <a href="https://sidecartridge.com/quickstart/" target="_blank" rel="noopener" style="color:#fde047;">sidecartridge.com/quickstart</a>
          </div>
          <div id="downloadFirmwareButton" style="display:none;">
            <a id="downloadFirmwareButtonLink" href="#" download style="display:inline-block; padding:8px 14px; border-radius:6px; background:#fde047; color:#111827; font-weight:600; text-decoration:none;">
              Download firmware
            </a>
          </div>
          <div id="downloadFirmwareLink" style="display:none;">
            <a id="downloadFirmwareLinkEl" href="#" download style="color:#fde047; text-decoration:none;">Click here to download the firmware</a>
          </div>
          <label>
            <button id="loadFirmware" type="button" class="secondary" disabled>Load firmware</button>
          </label>
        </div>
      </div>
    </li>
    <li id="step3" class="step">
      <div class="step-header">Step 3/4 <span>Pending</span></div>
      <div class="step-content">
        <div style="margin-bottom:8px;">Flashing process. Keep the device in BOOTSEL mode (use BOOTSEL or BOOT button).</div>
        <button id="grantUsb" class="secondary" type="button">Grant USB access</button>
        <div id="flashControls" style="display:none; margin-top:8px;">
          <button id="flash" disabled>Flash</button>
          <button id="restart" style="margin-left:12px; display:none;">Start again</button>
          <label style="margin-left:12px;">
            <input type="checkbox" id="doErase" checked>
            Erase before write
          </label>
          <label style="margin-left:12px;">
            <input type="checkbox" id="doVerify">
            Verify after write
          </label>
        </div>
        <div id="deviceWarning" style="margin-top:8px; color:#93c5fd; display:none;">
          RP2040 detected. Web flashing is enabled.
        </div>
      </div>
    </li>
    <li id="step4" class="step">
      <div class="step-header">Step 4/4 <span>Pending</span></div>
      <div class="step-content">
        <div id="postInstall" style="margin-bottom:8px;">Success. You can unplug or flash again.</div>
        <button id="flashAgain">Flash again</button>
        <button id="flashAnother" class="secondary" style="margin-left:12px;">Flash another device</button>
      </div>
    </li>
  </ul>

  <br>

  <br>

  <div id="fileName" style="margin:8px 0 6px; color:#cbd5f5;">File name: (none)</div>
  <div class="progress-wrap">
    <progress id="prog" value="0" max="100"></progress>
    <div id="progLabel" class="progress-label">0%</div>
  </div>

  <div style="margin:10px 0 6px; color:#cbd5f5; display:flex; align-items:center; gap:8px;">
    <button id="toggleLog" class="secondary" type="button">Hide process output</button>
  </div>
  <pre id="log"></pre>
</div>

<script>
const VID = 0x2E8A;
const PICOBOOT_PID_RP2040 = 0x0003;
const PICOBOOT_PID_RP2350 = 0x000F;
const DEVICES_JSON_URL = "https://s3.eu-west-3.amazonaws.com/tosemulator.sidecartridge.com/devices.json";
const UF2_MAGIC = 0x0A324655;
const UF2_MAGIC2 = 0x9E5D5157;
const UF2_END = 0x0AB16F30;
const UF2_FLAG_NOFLASH = 0x00000001;
const UF2_FLAG_FILE_CONTAINER = 0x00001000;
const UF2_FLAG_FAMILY_ID = 0x00002000;

const ADVANCED_UF2_VALIDATION = true;

const PICOBOOT_MAGIC = 0x431fd10b;

const CMD_EXCLUSIVE = 0x01;
const CMD_REBOOT = 0x02;
const CMD_ERASE = 0x03;
const CMD_WRITE = 0x05;
const CMD_EXIT_XIP = 0x06;
const CMD_REBOOT2 = 0x0A;
const REBOOT2_FLAG_REBOOT_TYPE_NORMAL = 0x0;

const FLASH_BASE = 0x10000000;
const SECTOR = 4096;

let uf2 = null;
let firmwareMeta = null;
let bootselDetected = false;
let bootselPermitted = false;
let flashingActive = false;
let bootselIsRp2040 = false;
let detectedMcu = null;
let deviceCatalog = null;
let webUsbSupported = false;
let deviceCatalogPromise = null;
let grantedUsbDevice = null;
let visibleFamilies = [];
let visibleFirmwares = [];
let awaitingPostFlashConfirm = false;

const logEl = document.getElementById("log");
const backLink = document.getElementById("backLink");
const progEl = document.getElementById("prog");
const progLabelEl = document.getElementById("progLabel");
const flashBtn = document.getElementById("flash");
const grantUsbBtn = document.getElementById("grantUsb");
const eraseToggle = document.getElementById("doErase");
const verifyToggle = document.getElementById("doVerify");
const restartBtn = document.getElementById("restart");
const flashControlsEl = document.getElementById("flashControls");
const fileNameEl = document.getElementById("fileName");
const flashAgainBtn = document.getElementById("flashAgain");
const flashAnotherBtn = document.getElementById("flashAnother");
const logToggleBtn = document.getElementById("toggleLog");
const appEl = document.getElementById("app");
const warningEl = document.getElementById("browserWarning");
const step1El = document.getElementById("step1");
const step2El = document.getElementById("step2");
const step3El = document.getElementById("step3");
const step4El = document.getElementById("step4");
const detectMcuBtn = document.getElementById("detectMcu");
const mcuDetectedEl = document.getElementById("mcuDetected");
const familySelect = document.getElementById("familySelect");
const firmwareSelect = document.getElementById("firmwareSelect");
const loadFirmwareBtn = document.getElementById("loadFirmware");
const deviceWarningEl = document.getElementById("deviceWarning");
const firmwareDetailsEl = document.getElementById("firmwareDetails");
const manualNoticeEl = document.getElementById("manualNotice");
const downloadFirmwareButtonEl = document.getElementById("downloadFirmwareButton");
const downloadFirmwareButtonLinkEl = document.getElementById("downloadFirmwareButtonLink");
const downloadFirmwareLinkEl = document.getElementById("downloadFirmwareLink");
const downloadFirmwareLinkAnchorEl = document.getElementById("downloadFirmwareLinkEl");
const familyDetailsEl = document.getElementById("familyDetails");
const familyImageEl = document.getElementById("familyImage");
const familyNameEl = document.getElementById("familyName");
const familyDescriptionEl = document.getElementById("familyDescription");
const postInstallEl = document.getElementById("postInstall");

if (backLink) {
  backLink.addEventListener("click", event => {
    event.preventDefault();
    if (window.history.length > 1) {
      window.history.back();
    } else {
      window.location.href = "/";
    }
  });
}

const log = m => {
  const ts = new Date().toLocaleTimeString();
  logEl.textContent += `[${ts}] ${m}\n`;
  logEl.scrollTop = logEl.scrollHeight;
};

function usbFilters() {
  return [
    { vendorId: VID, productId: PICOBOOT_PID_RP2040 },
    { vendorId: VID, productId: PICOBOOT_PID_RP2350 },
    { vendorId: VID }
  ];
}

function isBootselCandidate(dev) {
  return !!dev && dev.vendorId === VID;
}

async function selectUsbDeviceForFlash() {
  if (grantedUsbDevice) return grantedUsbDevice;

  const existing = await navigator.usb.getDevices();
  const candidate = existing.find(isBootselCandidate);
  if (candidate) {
    grantedUsbDevice = candidate;
    return candidate;
  }

  log("Request device...");
  const requested = await navigator.usb.requestDevice({ filters: usbFilters() });
  grantedUsbDevice = requested;
  return requested;
}

if (logToggleBtn) {
  logToggleBtn.addEventListener("click", () => {
    const isHidden = logEl.style.display === "none";
    logEl.style.display = isHidden ? "block" : "none";
    logToggleBtn.textContent = isHidden ? "Hide process output" : "Show process output";
  });
}

function updateFlashEnabled() {
  const mcuReady = !!detectedMcu;
  flashBtn.disabled = !(uf2 && bootselDetected && mcuReady) || !webUsbSupported;
  if (grantUsbBtn) grantUsbBtn.disabled = !webUsbSupported;
  if (flashControlsEl) {
    flashControlsEl.style.display = bootselPermitted && webUsbSupported ? "block" : "none";
  }
  updateFlashLabel();
}

function updateFlashLabel() {
  flashBtn.classList.remove("state-not-connected", "state-needs-access", "state-writing");
  if (!webUsbSupported) {
    flashBtn.textContent = "Web flashing not supported";
    flashBtn.classList.add("state-not-connected");
    return;
  }
  if (flashingActive) {
    flashBtn.textContent = "Writing firmware...";
    flashBtn.classList.add("state-writing");
    return;
  }
  if (!bootselDetected) {
    flashBtn.textContent = "Not connected";
    flashBtn.classList.add("state-not-connected");
    return;
  }
  if (!detectedMcu) {
    flashBtn.textContent = "Detect MCU first";
    flashBtn.classList.add("state-needs-access");
    return;
  }
  if (!bootselPermitted) {
    flashBtn.textContent = "Connected. Press button to grant access";
    flashBtn.classList.add("state-needs-access");
    return;
  }
  flashBtn.textContent = "Flash";
}

function setProgressMode(mode) {
  progEl.classList.remove("progress-load", "progress-erase", "progress-write", "progress-verify");
  if (mode) progEl.classList.add(mode);
}

function setProgressValue(value) {
  progEl.value = value;
  if (progLabelEl) progLabelEl.textContent = `${value}%`;
}

let lastUiUpdate = 0;
function shouldUpdateUi() {
  const now = Date.now();
  if (now - lastUiUpdate >= 150) {
    lastUiUpdate = now;
    return true;
  }
  return false;
}

function setStepState(activeStep, completedSteps = []) {
  const steps = [step1El, step2El, step3El, step4El];
  steps.forEach(step => {
    if (!step) return;
    step.classList.remove("active", "complete");
  });
  completedSteps.forEach(step => {
    if (step) step.classList.add("complete");
  });
  if (activeStep) activeStep.classList.add("active");
}

function setStepHeader(stepEl, statusText) {
  if (!stepEl) return;
  const span = stepEl.querySelector(".step-header span");
  if (span) span.textContent = statusText;
}

function updateMcuDetectedLabel() {
  if (!mcuDetectedEl) return;
  mcuDetectedEl.textContent = `MCU: ${detectedMcu || "(not detected)"}`;
  setStep1Header();
}

function setStep1Header() {
  if (!webUsbSupported) {
    setStepHeader(step1El, "Manual");
    return;
  }
  if (detectedMcu) {
    setStepHeader(step1El, `Complete (${detectedMcu})`);
  } else {
    setStepHeader(step1El, "Ready");
  }
}

function getMcuForDevice(dev) {
  if (!dev) return null;
  if (dev.productId === PICOBOOT_PID_RP2040) return "RP2040";
  if (dev.productId === PICOBOOT_PID_RP2350) return "RP2350";
  return null;
}

function resetFirmwareSelectionState() {
  firmwareMeta = null;
  uf2 = null;
  visibleFirmwares = [];
  if (familySelect) familySelect.value = "";
  if (firmwareSelect) {
    firmwareSelect.disabled = true;
    firmwareSelect.innerHTML = "<option value=\"\">Select a family first</option>";
  }
  if (familyDetailsEl) familyDetailsEl.style.display = "none";
  if (firmwareDetailsEl) firmwareDetailsEl.textContent = "Select a firmware to see details.";
  if (manualNoticeEl) manualNoticeEl.style.display = "none";
  if (downloadFirmwareButtonEl) downloadFirmwareButtonEl.style.display = "none";
  if (downloadFirmwareLinkEl) downloadFirmwareLinkEl.style.display = "none";
  if (loadFirmwareBtn) {
    loadFirmwareBtn.disabled = true;
    loadFirmwareBtn.style.display = "inline-block";
  }
  if (fileNameEl) fileNameEl.textContent = "File name: (none)";
  setProgressValue(0);
}

function applyDetectedMcu(mcu, opts = {}) {
  const { resetSelection = true, announceChange = false } = opts;
  const changed = detectedMcu !== mcu;
  detectedMcu = mcu;
  updateMcuDetectedLabel();
  if (resetSelection && changed) {
    resetFirmwareSelectionState();
  }
  renderFamilies();
  if (announceChange && changed && mcu) {
    log(`MCU changed to ${mcu}. Please select family and firmware again.`);
  }
  return changed;
}

function sanitizeAllowedHtml(rawHtml) {
  const fallback = "Success. You can unplug or flash again.";
  if (!rawHtml) return fallback;

  const template = document.createElement("template");
  template.innerHTML = rawHtml;
  const allowedTags = new Set(["A", "B", "BR", "EM", "I", "LI", "OL", "P", "STRONG", "U", "UL"]);
  const walker = document.createTreeWalker(template.content, NodeFilter.SHOW_ELEMENT);
  const toProcess = [];
  while (walker.nextNode()) toProcess.push(walker.currentNode);

  for (const el of toProcess) {
    if (!allowedTags.has(el.tagName)) {
      const textNode = document.createTextNode(el.textContent || "");
      el.replaceWith(textNode);
      continue;
    }

    for (const attr of [...el.attributes]) {
      const name = attr.name.toLowerCase();
      if (el.tagName === "A" && (name === "href" || name === "target" || name === "rel")) continue;
      el.removeAttribute(attr.name);
    }

    if (el.tagName === "A") {
      const href = el.getAttribute("href") || "";
      if (!/^https?:\/\//i.test(href)) {
        el.removeAttribute("href");
      } else {
        el.setAttribute("target", "_blank");
        el.setAttribute("rel", "noopener");
      }
    }
  }

  return template.innerHTML || fallback;
}

function renderFirmwareDetails(meta, manualOnly) {
  if (!firmwareDetailsEl || !meta) return;
  firmwareDetailsEl.textContent = "";

  const title = document.createElement("strong");
  title.textContent = meta.name || "Firmware";
  firmwareDetailsEl.appendChild(title);
  firmwareDetailsEl.appendChild(document.createElement("br"));

  firmwareDetailsEl.appendChild(document.createTextNode(`Version: ${meta.version || "unknown"}`));
  firmwareDetailsEl.appendChild(document.createElement("br"));
  firmwareDetailsEl.appendChild(document.createTextNode(meta.description || ""));

  if (!manualOnly) {
    firmwareDetailsEl.appendChild(document.createTextNode(" ("));
    const link = document.createElement("a");
    link.href = meta.uf2_url;
    link.download = "";
    link.style.color = "#fde047";
    link.style.textDecoration = "none";
    link.textContent = "Click here to download the firmware";
    firmwareDetailsEl.appendChild(link);
    firmwareDetailsEl.appendChild(document.createTextNode(")"));
  }
}

function renderManualNotice(manualOnly) {
  if (!manualNoticeEl) return;
  if (!manualOnly) {
    manualNoticeEl.style.display = "none";
    return;
  }

  manualNoticeEl.textContent = "Web flashing is not available in this browser. Please follow the manual BOOTSEL or BOOT button instructions in the quickstart guide: ";
  const link = document.createElement("a");
  link.href = "https://sidecartridge.com/quickstart/";
  link.target = "_blank";
  link.rel = "noopener";
  link.style.color = "#fde047";
  link.textContent = "sidecartridge.com/quickstart";
  manualNoticeEl.appendChild(link);
  manualNoticeEl.style.display = "block";
}

function isChromiumBrowser() {
  const ua = navigator.userAgent;
  const hasChromium = /Chrome|Chromium|Edg|Brave/.test(ua);
  const isFirefox = /Firefox/.test(ua);
  const isSafari = /Safari/.test(ua) && !/Chrome|Chromium|Edg|Brave/.test(ua);
  return hasChromium && !isFirefox && !isSafari;
}

function enforceBrowserSupport() {
  const chromium = isChromiumBrowser();
  webUsbSupported = !!navigator.usb && chromium;
  if (!webUsbSupported) {
    if (warningEl) {
      warningEl.style.display = "block";
      warningEl.textContent = chromium
        ? "Web flashing is not supported in this browser. Please use the manual BOOTSEL or BOOT button procedure and download the firmware instead."
        : "Web flashing is only supported in Chromium-based browsers (Chrome/Edge/Brave). Please use manual BOOTSEL or BOOT button procedure and download the firmware instead.";
    }
    if (detectMcuBtn) detectMcuBtn.disabled = true;
    if (mcuDetectedEl) mcuDetectedEl.textContent = "MCU: detection not required in this browser";
    setStepState(step2El, [step1El]);
    setStepHeader(step1El, "Manual");
    setStepHeader(step2El, "Ready");
  }
  return webUsbSupported;
}

enforceBrowserSupport();

async function loadFirmwareCatalog() {
  if (deviceCatalogPromise) {
    return deviceCatalogPromise;
  }
  deviceCatalogPromise = (async () => {
  try {
    const response = await fetch(DEVICES_JSON_URL);
    if (!response.ok) throw new Error("Unable to load devices.json");
    deviceCatalog = await response.json();
    renderFamilies();
  } catch (err) {
    log("ERROR: " + err.message);
    if (familySelect) {
      familySelect.innerHTML = "<option value=\"\">Failed to load devices.json</option>";
    }
    throw err;
  }
  return deviceCatalog;
  })();
  return deviceCatalogPromise;
}

function renderFamilies() {
  if (!familySelect || !deviceCatalog || !Array.isArray(deviceCatalog.families)) return;
  if (webUsbSupported && !detectedMcu) {
    familySelect.disabled = true;
    familySelect.innerHTML = "<option value=\"\">Detect MCU first</option>";
    return;
  }
  if (webUsbSupported) {
    visibleFamilies = deviceCatalog.families
      .map((family, index) => ({ family, index }))
      .filter(({ family }) =>
        (family.firmwares || []).some(fw => (fw.device_type || "").toUpperCase() === detectedMcu)
      );
  } else {
    visibleFamilies = deviceCatalog.families.map((family, index) => ({ family, index }));
  }

  familySelect.innerHTML = "<option value=\"\">Select a family...</option>";
  visibleFamilies.forEach(({ family, index }) => {
    const option = document.createElement("option");
    option.value = String(index);
    option.textContent = family.name;
    familySelect.appendChild(option);
  });
  familySelect.disabled = visibleFamilies.length === 0;
  if (visibleFamilies.length === 0) {
    familySelect.innerHTML = "<option value=\"\">No compatible families for detected MCU</option>";
  }
}

function renderFirmwares(familyIndex) {
  if (!firmwareSelect || !deviceCatalog) return;
  visibleFirmwares = [];
  firmwareSelect.innerHTML = "";
  loadFirmwareBtn.disabled = true;
  loadFirmwareBtn.style.display = "inline-block";
  if (firmwareDetailsEl) {
    firmwareDetailsEl.textContent = "Select a firmware to see details.";
  }
  if (manualNoticeEl) manualNoticeEl.style.display = "none";
  if (downloadFirmwareButtonEl) downloadFirmwareButtonEl.style.display = "none";
  if (downloadFirmwareLinkEl) downloadFirmwareLinkEl.style.display = "none";
  if (familyDetailsEl) {
    familyDetailsEl.style.display = "none";
  }
  firmwareMeta = null;
  uf2 = null;
  if (fileNameEl) fileNameEl.textContent = "File name: (none)";
  setProgressValue(0);
  updateFlashEnabled();

  if (familyIndex === "") {
    firmwareSelect.disabled = true;
    firmwareSelect.innerHTML = "<option value=\"\">Select a family first</option>";
    return;
  }

  const family = deviceCatalog.families[Number(familyIndex)];
  const firmwares = family
    ? (webUsbSupported
      ? (family.firmwares || []).filter(fw => (fw.device_type || "").toUpperCase() === detectedMcu)
      : (family.firmwares || []))
    : [];
  visibleFirmwares = firmwares;
  if (familyDetailsEl && family) {
    familyDetailsEl.style.display = "grid";
    if (familyImageEl) familyImageEl.src = family.image || "";
    if (familyNameEl) familyNameEl.textContent = family.name || "Family";
    if (familyDescriptionEl) familyDescriptionEl.textContent = family.description || "";
  }
  firmwareSelect.disabled = false;
  firmwareSelect.innerHTML = "<option value=\"\">Select a firmware...</option>";
  if (firmwares.length === 0) {
    firmwareSelect.disabled = true;
    firmwareSelect.innerHTML = "<option value=\"\">No compatible firmware for detected MCU</option>";
    return;
  }
  firmwares.forEach((fw, index) => {
    const option = document.createElement("option");
    option.value = String(index);
    option.textContent = `${fw.name} (${fw.version})`;
    firmwareSelect.appendChild(option);
  });
}

async function loadFirmwareSelection() {
  if (!firmwareMeta) return;
  if (!webUsbSupported) {
    setStepState(step3El, [step1El, step2El]);
    setStep1Header();
    setStepHeader(step2El, "Complete");
    setStepHeader(step3El, "Manual");
    log("Web flashing is not available. Use manual BOOTSEL or BOOT button instructions.");
    updateFlashEnabled();
    return;
  }
  try {
    log("Downloading UF2...");
    setStepState(step2El, [step1El]);
    setStepHeader(step2El, "Working");
    if (fileNameEl) fileNameEl.textContent = `File name: ${firmwareMeta.uf2_url.split("/").pop()}`;
    const response = await fetch(firmwareMeta.uf2_url);
    if (!response.ok) throw new Error("Unable to download UF2 file");
    const buf = await response.arrayBuffer();
    setProgressMode("progress-load");
    setProgressValue(0);
    uf2 = await parseUF2(buf, progress => {
      setProgressValue(progress);
      if (progress % 10 === 0) {
        log(`Parsing UF2... ${progress}%`);
      }
    });
    log(`Blocks: ${uf2.blocks.length}`);
    log(`Erase ranges: ${uf2.ranges.length}`);
    setStepState(step3El, [step1El, step2El]);
    setStep1Header();
    setStepHeader(step2El, "Complete");
    setStepHeader(step3El, "Ready");
    updateFlashEnabled();
  } catch (err) {
    uf2 = null;
    updateFlashEnabled();
    log("ERROR: " + err.message);
  }
}

if (familySelect) {
  familySelect.addEventListener("change", event => {
    renderFirmwares(event.target.value);
  });
}

if (firmwareSelect) {
  firmwareSelect.addEventListener("change", event => {
    const familyIndex = familySelect.value;
    const fwIndex = event.target.value;
    if (familyIndex === "" || fwIndex === "") {
    firmwareMeta = null;
    loadFirmwareBtn.disabled = true;
    loadFirmwareBtn.style.display = "inline-block";
    if (manualNoticeEl) manualNoticeEl.style.display = "none";
    if (downloadFirmwareButtonEl) downloadFirmwareButtonEl.style.display = "none";
    if (downloadFirmwareLinkEl) downloadFirmwareLinkEl.style.display = "none";
    return;
  }
    firmwareMeta = visibleFirmwares[Number(fwIndex)];
    const manualOnly = !webUsbSupported;
    renderFirmwareDetails(firmwareMeta, manualOnly);
    if (downloadFirmwareButtonLinkEl) {
      downloadFirmwareButtonLinkEl.href = firmwareMeta.uf2_url;
    }
    if (downloadFirmwareLinkAnchorEl) {
      downloadFirmwareLinkAnchorEl.href = firmwareMeta.uf2_url;
    }
    if (manualOnly) {
      if (downloadFirmwareButtonEl) downloadFirmwareButtonEl.style.display = "block";
      if (downloadFirmwareLinkEl) downloadFirmwareLinkEl.style.display = "none";
      loadFirmwareBtn.disabled = true;
      loadFirmwareBtn.style.display = "none";
    } else {
      if (downloadFirmwareButtonEl) downloadFirmwareButtonEl.style.display = "none";
      if (downloadFirmwareLinkEl) downloadFirmwareLinkEl.style.display = "none";
      loadFirmwareBtn.disabled = false;
      loadFirmwareBtn.style.display = "inline-block";
    }
    renderManualNotice(manualOnly);
    if (postInstallEl) {
      postInstallEl.innerHTML = sanitizeAllowedHtml(firmwareMeta.post_install_html);
    }
  });
}

if (loadFirmwareBtn) {
  loadFirmwareBtn.addEventListener("click", () => {
    loadFirmwareSelection();
  });
}

if (detectMcuBtn) {
  detectMcuBtn.addEventListener("click", async () => {
    if (!webUsbSupported) {
      log("Web flashing is not supported in this browser.");
      return;
    }
    try {
      setStepState(step1El);
      setStepHeader(step1El, "Working");
      log("Detecting MCU...");
      const dev = await selectUsbDeviceForFlash();
      grantedUsbDevice = dev;
      bootselPermitted = true;
      bootselDetected = true;
      bootselIsRp2040 = dev.productId === PICOBOOT_PID_RP2040;
      const mcu = getMcuForDevice(dev);
      applyDetectedMcu(mcu, { resetSelection: true });
      if (!detectedMcu) throw new Error("Unsupported device detected");
      if (deviceWarningEl) deviceWarningEl.style.display = bootselIsRp2040 ? "block" : "none";
      log(`Detected MCU: ${detectedMcu}`);
      setStepState(step2El, [step1El]);
      setStep1Header();
      setStepHeader(step2El, "Ready");
      updateFlashEnabled();
    } catch (err) {
      setStep1Header();
      log(`MCU detection failed (${err.message}).`);
    }
  });
}

if (grantUsbBtn) {
  grantUsbBtn.addEventListener("click", async () => {
    if (!webUsbSupported) {
      log("Web flashing is not supported in this browser.");
      return;
    }
    try {
      log("Requesting USB access...");
      const dev = await navigator.usb.requestDevice({ filters: usbFilters() });
      grantedUsbDevice = dev;
      bootselIsRp2040 = dev.productId === PICOBOOT_PID_RP2040;
      if (deviceWarningEl) {
        deviceWarningEl.style.display = bootselIsRp2040 ? "block" : "none";
      }
      bootselPermitted = true;
      bootselDetected = true;
      log(`USB access granted: ${describeDevice(dev)}`);
      updateFlashEnabled();
    } catch (err) {
      log(`USB access request canceled (${err.message}).`);
    }
  });
}

document.getElementById("flash").onclick = async () => {
  awaitingPostFlashConfirm = false;
  if (!detectedMcu) {
    log("Please complete Step 1 and detect MCU before flashing.");
    return;
  }
  if (!uf2) return;
  if (!webUsbSupported) {
    log("Web flashing is not supported in this browser. Use the manual BOOTSEL procedure.");
    return;
  }

  let pico = null;
  try {
    setStepState(step3El, [step1El, step2El]);
    setStep1Header();
    setStepHeader(step2El, "Complete");
    setStepHeader(step3El, "Working");
    flashingActive = true;
    updateFlashLabel();
    const dev = await selectUsbDeviceForFlash();
    bootselIsRp2040 = dev.productId === PICOBOOT_PID_RP2040;
    const connectedMcu = getMcuForDevice(dev);
    if (deviceWarningEl) {
      deviceWarningEl.style.display = bootselIsRp2040 ? "block" : "none";
    }
    log(`Detected device: ${describeDevice(dev)}`);
    if (!connectedMcu) {
      throw new Error("Unsupported device detected.");
    }
    if (!detectedMcu || detectedMcu !== connectedMcu) {
      throw new Error(`Detected MCU (${detectedMcu || "none"}) does not match connected device (${connectedMcu}). Please run Step 1 again.`);
    }
    if (!firmwareMeta || (firmwareMeta.device_type || "").toUpperCase() !== connectedMcu) {
      throw new Error(`Selected firmware is not compatible with ${connectedMcu}. Please select firmware again.`);
    }
    bootselPermitted = true;
    bootselDetected = true;
    updateFlashEnabled();

    if (bootselIsRp2040) {
      log("RP2040 detected. Continuing with WebUSB flashing.");
    }

    await dev.open();
    if (!dev.configuration) await dev.selectConfiguration(1);

    const iface = findIface(dev.configuration);
    if (!iface) throw new Error("No vendor interface found.");
    log(`Using interface ${iface.iface}, endpoints out=${iface.out} in=${iface.in}`);

    pico = new PicoTool(dev, iface.iface, iface.out, iface.in);

    log("Open + reset");
    await pico.open();
    await pico.reset();

    log("Exclusive access");
    try {
      await pico.exclusiveAccess(1);
    } catch (err) {
      log(`Exclusive access failed (${err.message}); continuing...`);
    }

    log("Exit XIP");
    await pico.exitXip();

    if (eraseToggle && eraseToggle.checked) {
      setProgressMode("progress-erase");
      setProgressValue(0);
      const totalEraseSectors = uf2.ranges.reduce(
        (sum, r) => sum + Math.ceil((r.end - r.start) / SECTOR),
        0
      );
      let erasedSectors = 0;
      let lastEraseLogged = -1;
      log(`Erasing ${totalEraseSectors} sectors...`);

      for (const r of uf2.ranges) {
        log(`Erase 0x${r.start.toString(16)} (${r.end - r.start} bytes)`);
        for (let addr = r.start; addr < r.end; addr += SECTOR) {
          await pico.flashErase(addr, SECTOR, 10000);
          erasedSectors += 1;
          const progress = Math.round((erasedSectors / totalEraseSectors) * 100);
          if (shouldUpdateUi() || erasedSectors === totalEraseSectors) {
            setProgressValue(progress);
          }
          if (progress !== lastEraseLogged) {
            lastEraseLogged = progress;
            log(`Erase progress: ${progress}% (${erasedSectors}/${totalEraseSectors} sectors)`);
          }
          if ((erasedSectors % 8) === 0) await tick();
        }
      }
      setProgressValue(100);
    } else {
      log("Erase skipped.");
    }

    setProgressMode("progress-write");
    let i = 0;
    let lastWriteLogged = -1;
    for (const b of uf2.blocks) {
      i++;
      const progress = Math.round((i / uf2.blocks.length) * 100);
      if (shouldUpdateUi()) setProgressValue(progress);
      if (progress !== lastWriteLogged) {
        lastWriteLogged = progress;
        log(`Write progress: ${progress}%`);
      }
      await pico.write(b.addr, b.data);
      if (i % 32 === 0) await tick();
    }

    if (verifyToggle && verifyToggle.checked) {
      log("Verifying written data...");
      setProgressMode("progress-verify");
      let v = 0;
      let lastVerifyLogged = -1;
      for (const b of uf2.blocks) {
        v++;
        const progress = Math.round((v / uf2.blocks.length) * 100);
        if (shouldUpdateUi()) setProgressValue(progress);
        if (progress !== lastVerifyLogged) {
          lastVerifyLogged = progress;
          log(`Verify progress: ${progress}%`);
        }
        const expected = new Uint8Array(b.data);
        const readBack = await pico.read(b.addr, expected.length, 5000);
        if (!readBack || readBack.length !== expected.length) {
          throw new Error(`Verification failed at 0x${b.addr.toString(16)} (read length mismatch)`);
        }
        for (let idx = 0; idx < expected.length; idx += 1) {
          if (readBack[idx] !== expected[idx]) {
            throw new Error(`Verification failed at 0x${(b.addr + idx).toString(16)}`);
          }
        }
        if (v % 32 === 0) await tick();
      }
      log("Verification successful.");
    }

    setStepState(step4El, [step1El, step2El, step3El]);
    setStepHeader(step3El, "Complete");
    setStepHeader(step4El, "Success");
    if (postInstallEl && firmwareMeta) {
      postInstallEl.innerHTML = sanitizeAllowedHtml(firmwareMeta.post_install_html);
    }
    if (flashAgainBtn) {
      flashAgainBtn.style.display = "inline-block";
    }
    awaitingPostFlashConfirm = true;

    log("Reboot");
    try {
      await pico.rebootToApp(500);
      log("Reboot command sent (device may disconnect immediately).");
    } catch (e) {
      log(`Reboot command failed (${e.message}). You can unplug the device manually.`);
    }

  } catch (e) {
    awaitingPostFlashConfirm = false;
    log("ERROR: " + e.message);
  } finally {
    if (pico) {
      try {
        await pico.close();
      } catch (_) {}
    }
    flashingActive = false;
    updateFlashEnabled();
  }
};

if (restartBtn) {
  restartBtn.addEventListener("click", () => {
    awaitingPostFlashConfirm = false;
    window.location.reload();
  });
}

if (flashAgainBtn) {
  flashAgainBtn.addEventListener("click", () => {
    awaitingPostFlashConfirm = false;
    window.location.reload();
  });
}

if (flashAnotherBtn) {
  flashAnotherBtn.addEventListener("click", () => {
    awaitingPostFlashConfirm = false;
    // Keep the loaded firmware, reset device state for a new flash.
    bootselDetected = false;
    bootselPermitted = false;
    flashingActive = false;
    setProgressValue(0);
    setProgressMode("progress-write");
    setStepState(step3El, [step1El, step2El]);
    setStepHeader(step3El, "Ready");
    updateFlashEnabled();
  });
}

async function detectBootselDevices() {
  if (!navigator.usb) return;
  const devices = await navigator.usb.getDevices();
  bootselPermitted = devices.some(dev => dev.vendorId === VID);
  grantedUsbDevice = devices.find(isBootselCandidate) || null;
  bootselIsRp2040 = devices.some(dev => dev.vendorId === VID && dev.productId === PICOBOOT_PID_RP2040);
  if (grantedUsbDevice) {
    const newMcu = getMcuForDevice(grantedUsbDevice);
    const changed = applyDetectedMcu(newMcu, { resetSelection: detectedMcu !== null, announceChange: detectedMcu !== null });
    if (detectedMcu) {
      setStepState(step2El, [step1El]);
      setStep1Header();
      setStepHeader(step2El, "Ready");
      if (changed) {
        setStepHeader(step3El, "Pending");
        setStepHeader(step4El, "Pending");
      }
    }
  }
  bootselDetected = bootselPermitted;
  if (deviceWarningEl) {
    deviceWarningEl.style.display = bootselIsRp2040 ? "block" : "none";
  }
  updateFlashEnabled();
}

if (webUsbSupported && navigator.usb) {
  navigator.usb.addEventListener("connect", event => {
    if (event.device && event.device.vendorId === VID) {
      if (awaitingPostFlashConfirm) {
        grantedUsbDevice = event.device;
        bootselDetected = true;
        bootselPermitted = true;
        log(`Detected device: ${describeDevice(event.device)}`);
        updateFlashEnabled();
        return;
      }
      grantedUsbDevice = event.device;
      bootselDetected = true;
      bootselIsRp2040 = event.device.productId === PICOBOOT_PID_RP2040;
      const newMcu = getMcuForDevice(event.device);
      if (newMcu) {
        const changed = applyDetectedMcu(newMcu, { resetSelection: detectedMcu !== null, announceChange: detectedMcu !== null });
        setStepState(step2El, [step1El]);
        setStep1Header();
        setStepHeader(step2El, "Ready");
        if (changed) {
          setStepHeader(step3El, "Pending");
          setStepHeader(step4El, "Pending");
        }
      }
      if (deviceWarningEl) {
        deviceWarningEl.style.display = bootselIsRp2040 ? "block" : "none";
      }
      log(`Detected device: ${describeDevice(event.device)}`);
      updateFlashEnabled();
    }
  });

  navigator.usb.addEventListener("disconnect", event => {
    if (event.device && event.device.vendorId === VID) {
      if (awaitingPostFlashConfirm) {
        grantedUsbDevice = null;
        bootselDetected = false;
        bootselPermitted = false;
        bootselIsRp2040 = false;
        log("Device disconnected after reboot. Waiting for your confirmation.");
        updateFlashEnabled();
        return;
      }
      if (grantedUsbDevice && event.device === grantedUsbDevice) {
        grantedUsbDevice = null;
        applyDetectedMcu(null, { resetSelection: true });
        setStepState(step1El);
        setStep1Header();
        setStepHeader(step2El, "Pending");
        setStepHeader(step3El, "Pending");
        setStepHeader(step4El, "Pending");
      }
      bootselDetected = false;
      bootselPermitted = false;
      bootselIsRp2040 = false;
      if (deviceWarningEl) {
        deviceWarningEl.style.display = "none";
      }
      updateFlashEnabled();
    }
  });

  detectBootselDevices();
}

loadFirmwareCatalog();
updateMcuDetectedLabel();

function describeDevice(device) {
  if (!device) return "Unknown device";
  if (device.productId === PICOBOOT_PID_RP2040) return "RP2040 (BOOTSEL)";
  if (device.productId === PICOBOOT_PID_RP2350) return "RP2350 (BOOTSEL)";
  return `RP2 device (PID 0x${device.productId.toString(16).padStart(4, "0")})`;
}

async function parseUF2(buf, onProgress) {
  if (buf.byteLength % 512) throw new Error("Bad UF2 size");

  const dv = new DataView(buf);
  const blocks = [];
  const ranges = [];
  const totalBlocks = buf.byteLength / 512;
  let lastProgress = -1;
  let expectedNumBlocks = null;
  const blockNumbers = new Set();

  for (let o = 0, idx = 0; o < buf.byteLength; o += 512, idx += 1) {
    if (dv.getUint32(o, true) !== UF2_MAGIC) throw new Error("Bad UF2 magic");
    if (dv.getUint32(o + 4, true) !== UF2_MAGIC2) throw new Error("Bad UF2 magic2");
    if (dv.getUint32(o + 508, true) !== UF2_END) throw new Error("Bad UF2 end magic");

    const flags = dv.getUint32(o + 8, true);
    if (flags & UF2_FLAG_NOFLASH) continue;

    let addr = dv.getUint32(o + 12, true);
    const size = dv.getUint32(o + 16, true);
    const blockNo = dv.getUint32(o + 20, true);
    const numBlocks = dv.getUint32(o + 24, true);
    if (size <= 0 || size > 476) throw new Error("Invalid UF2 payload size");

    if (ADVANCED_UF2_VALIDATION) {
      if (expectedNumBlocks === null) expectedNumBlocks = numBlocks;
      if (numBlocks !== expectedNumBlocks) {
        throw new Error("UF2 block count mismatch");
      }
      if (blockNo >= numBlocks) {
        throw new Error("UF2 block number out of range");
      }
      blockNumbers.add(blockNo);
      if (flags & UF2_FLAG_FILE_CONTAINER) {
        throw new Error("UF2 file container not supported");
      }
      if (flags & UF2_FLAG_FAMILY_ID) {
        const familyId = dv.getUint32(o + 28, true);
        if (!familyId) {
          throw new Error("UF2 family ID flag set but ID missing");
        }
      }
    }

    if (addr < FLASH_BASE) addr += FLASH_BASE;

    blocks.push({
      addr,
      data: buf.slice(o + 32, o + 32 + size)
    });

    const start = addr & ~(SECTOR - 1);
    const end = (addr + size + SECTOR - 1) & ~(SECTOR - 1);
    ranges.push({ start, end });

    const progress = Math.floor(((idx + 1) / totalBlocks) * 100);
    if (progress !== lastProgress) {
      lastProgress = progress;
      if (onProgress) onProgress(progress);
    }
    if ((o & 0x7fff) === 0) await tick();
  }

  if (ADVANCED_UF2_VALIDATION && expectedNumBlocks !== null) {
    if (blockNumbers.size === 0) throw new Error("UF2 contains no flashable blocks");
  }

  blocks.sort((a, b) => a.addr - b.addr);

  ranges.sort((a, b) => a.start - b.start);
  const merged = [];
  for (const r of ranges) {
    const last = merged[merged.length - 1];
    if (last && r.start <= last.end) {
      last.end = Math.max(last.end, r.end);
    } else {
      merged.push({ start: r.start, end: r.end });
    }
  }

  return { blocks, ranges: merged };
}

function findIface(cfg) {
  const preferredIndex = cfg.interfaces.length <= 1 ? 0 : 1;
  const preferred = cfg.interfaces[preferredIndex];
  if (preferred) {
    const alt = preferred.alternates[0];
    if (alt && alt.interfaceClass === 0xff) {
      const o = alt.endpoints.find(e => e.direction === "out");
      const n = alt.endpoints.find(e => e.direction === "in");
      if (o && n) {
        return { iface: preferred.interfaceNumber, out: o.endpointNumber, in: n.endpointNumber };
      }
    }
  }

  for (const i of cfg.interfaces) {
    for (const a of i.alternates) {
      if (a.interfaceClass !== 0xff) continue;
      const o = a.endpoints.find(e => e.direction === "out");
      const n = a.endpoints.find(e => e.direction === "in");
      if (o && n) {
        return { iface: i.interfaceNumber, out: o.endpointNumber, in: n.endpointNumber };
      }
    }
  }
  return null;
}

async function tick() {
  return new Promise(r => setTimeout(r, 0));
}

function withTimeout(promise, ms, label) {
  let timer;
  const timeout = new Promise((_, reject) => {
    timer = setTimeout(() => {
      reject(new Error(`${label} timed out after ${ms}ms`));
    }, ms);
  });

  return Promise.race([promise, timeout]).finally(() => clearTimeout(timer));
}

class PicoTool {
  static SRAM_END = 0x20042000;

  constructor(device, iface, outEndpoint, inEndpoint) {
    this.device = device;
    this.iface = iface;
    this.outEndpoint = outEndpoint;
    this.inEndpoint = inEndpoint;
    this.token = 1;
  }

  async open() {
    await this.device.claimInterface(this.iface);
  }

  async close() {
    try { await this.device.close(); } catch (_) {}
  }

  async reset() {
    await withTimeout(this.device.controlTransferOut({
      requestType: "vendor",
      recipient: "interface",
      request: 0x41,
      value: 0x00,
      index: this.iface
    }), 3000, "controlTransferOut");
  }

  async exclusiveAccess(enabled) {
    const cmd = new ArrayBuffer(1);
    new DataView(cmd).setUint8(0, enabled ? 1 : 0);
    await this.runCmd(CMD_EXCLUSIVE, cmd);
  }

  async reboot(pc, sp, delayMs) {
    const cmd = new ArrayBuffer(12);
    const view = new DataView(cmd);
    view.setUint32(0, pc >>> 0, true);
    view.setUint32(4, sp >>> 0, true);
    view.setUint32(8, delayMs >>> 0, true);

    try {
      // This uses the exact same PC_REBOOT packet layout as picotool:
      // bCmdId=0x02, bCmdSize=12, dTransferLength=0, reboot_cmd in the union.
      await this.runCmd(CMD_REBOOT, cmd);
    } catch (e) {
      if (!PicoTool.isExpectedDisconnectError(e)) throw e;
    }
  }

  async reboot2(flags, delayMs, param0 = 0, param1 = 0) {
    const cmd = new ArrayBuffer(16);
    const view = new DataView(cmd);
    view.setUint32(0, flags >>> 0, true);
    view.setUint32(4, delayMs >>> 0, true);
    view.setUint32(8, param0 >>> 0, true);
    view.setUint32(12, param1 >>> 0, true);

    try {
      await this.runCmd(CMD_REBOOT2, cmd);
    } catch (e) {
      if (!PicoTool.isExpectedDisconnectError(e)) throw e;
    }
  }

  async rebootToApp(delayMs = 500) {
    if (this.device && this.device.productId === PICOBOOT_PID_RP2350) {
      await this.reboot2(REBOOT2_FLAG_REBOOT_TYPE_NORMAL, delayMs, 0, 0);
      return;
    }
    await this.reboot(0, PicoTool.SRAM_END, delayMs);
  }

  static isExpectedDisconnectError(e) {
    // On reboot, WebUSB often throws because the device disconnects
    // before the status stage completes. Treat that as success.
    const name = e?.name || "";
    const msg = (e?.message || "").toLowerCase();
    return (
      name === "NetworkError" ||
      name === "NotFoundError" ||
      name === "AbortError" ||
      msg.includes("disconnected") ||
      msg.includes("device") ||
      msg.includes("transfer") ||
      msg.includes("not found")
    );
  }

  async flashErase(addr, size, timeoutMs) {
    const cmd = new ArrayBuffer(8);
    const view = new DataView(cmd);
    view.setUint32(0, addr, true);
    view.setUint32(4, size, true);
    await this.runCmd(CMD_ERASE, cmd, undefined, timeoutMs);
  }

  async write(addr, data) {
    const cmd = new ArrayBuffer(8);
    const view = new DataView(cmd);
    view.setUint32(0, addr, true);
    view.setUint32(4, data.byteLength, true);
    await this.runCmd(CMD_WRITE, cmd, data);
  }

  async exitXip() {
    await this.runCmd(CMD_EXIT_XIP);
  }

  async read(addr, size, timeoutMs) {
    const cmd = new ArrayBuffer(8);
    const view = new DataView(cmd);
    view.setUint32(0, addr, true);
    view.setUint32(4, size, true);
    return await this.runCmd(0x84, cmd, size, timeoutMs || 3000);
  }

  async runCmd(cmdId, cmdData, transferLengthOrData, timeoutMs = 3000) {
    const cmd = new ArrayBuffer(32);
    const view = new DataView(cmd);

    view.setUint32(0, PICOBOOT_MAGIC, true);
    view.setUint32(4, this.token++, true);
    view.setUint8(8, cmdId);
    view.setUint8(9, cmdData ? cmdData.byteLength : 0);
    view.setUint16(10, 0x0000, true);

    if (transferLengthOrData === undefined) {
      view.setUint32(12, 0, true);
    } else if (typeof transferLengthOrData === "number") {
      view.setUint32(12, transferLengthOrData, true);
    } else {
      view.setUint32(12, transferLengthOrData.byteLength, true);
    }

    if (cmdData) {
      const src = new Uint8Array(cmdData);
      new Uint8Array(cmd, 16, src.length).set(src);
    }

    await withTimeout(this.device.transferOut(this.outEndpoint, cmd), timeoutMs, "transferOut(cmd)");

    let transferInResult;
    if (transferLengthOrData !== undefined) {
      if (cmdId & 0x80) {
        transferInResult = await withTimeout(
          this.device.transferIn(this.inEndpoint, transferLengthOrData),
          timeoutMs,
          "transferIn(data)"
        );
      } else {
        await withTimeout(
          this.device.transferOut(this.outEndpoint, transferLengthOrData),
          timeoutMs,
          "transferOut(data)"
        );
      }
    }

    if (cmdId & 0x80) {
      await withTimeout(
        this.device.transferOut(this.outEndpoint, new Uint8Array(0)),
        timeoutMs,
        "transferOut(ack zlp)"
      );
    } else {
      transferInResult = await withTimeout(
        this.device.transferIn(this.inEndpoint, 64),
        timeoutMs,
        "transferIn(status)"
      );
    }

    return transferInResult ? new Uint8Array(transferInResult.data.buffer) : null;
  }
}
</script>

</body>
</html>
