<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>RP2040 / RP2350 WebUSB Flasher</title>
<style>
body {
  font-family: system-ui;
  background: #0b0f17;
  color: #e5e7eb;
  padding: 20px;
}

button {
  padding: 8px 14px;
  border-radius: 6px;
  border: none;
  background: #f97316;
  font-weight: 600;
}

button:disabled {
  opacity: .5;
}

pre {
  background: #111827;
  padding: 10px;
  border-radius: 6px;
  height: 220px;
  overflow: auto;
}

progress {
  width: 100%;
  height: 10px;
  appearance: none;
  border-radius: 999px;
  background: rgba(148, 163, 184, 0.25);
  overflow: hidden;
}

progress::-webkit-progress-bar {
  background: transparent;
}

progress::-webkit-progress-value {
  background: #3b82f6;
}

progress::-moz-progress-bar {
  background: #3b82f6;
}

progress.progress-load::-webkit-progress-value {
  background: #3b82f6;
}

progress.progress-load::-moz-progress-bar {
  background: #3b82f6;
}

progress.progress-erase::-webkit-progress-value {
  background: #ef4444;
}

progress.progress-erase::-moz-progress-bar {
  background: #ef4444;
}

progress.progress-write::-webkit-progress-value {
  background: #22c55e;
}

progress.progress-write::-moz-progress-bar {
  background: #22c55e;
}
</style>
</head>

<body>

<h2>RP2040 / RP2350 WebUSB UF2 Flasher</h2>

<p>1) Select UF2<br>
2) Plug Pico / RP2350 in BOOTSEL<br>
3) Click Flash</p>

<input type="file" id="file" accept=".uf2"><br><br>

<button id="flash" disabled>Flash</button>
<label style="margin-left:12px;">
  <input type="checkbox" id="doErase" checked>
  Erase before write
</label>

<br><br>

<progress id="prog" value="0" max="100"></progress>

<pre id="log"></pre>

<script>
const VID = 0x2E8A;
const UF2_MAGIC = 0x0A324655;
const UF2_MAGIC2 = 0x9E5D5157;
const UF2_END = 0x0AB16F30;
const UF2_FLAG_NOFLASH = 0x00000001;

const PICOBOOT_MAGIC = 0x431fd10b;

const CMD_EXCLUSIVE = 0x01;
const CMD_REBOOT = 0x02;
const CMD_ERASE = 0x03;
const CMD_WRITE = 0x05;
const CMD_EXIT_XIP = 0x06;

const FLASH_BASE = 0x10000000;
const SECTOR = 4096;

let uf2 = null;

const logEl = document.getElementById("log");
const progEl = document.getElementById("prog");
const flashBtn = document.getElementById("flash");
const eraseToggle = document.getElementById("doErase");

const log = m => {
  logEl.textContent += m + "\n";
  logEl.scrollTop = logEl.scrollHeight;
};

function setProgressMode(mode) {
  progEl.classList.remove("progress-load", "progress-erase", "progress-write");
  if (mode) progEl.classList.add(mode);
}

document.getElementById("file").onchange = async e => {
  const f = e.target.files[0];
  if (!f) return;

  try {
    log("Loading UF2...");
    const buf = await f.arrayBuffer();
    setProgressMode("progress-load");
    progEl.value = 0;
    uf2 = await parseUF2(buf, progress => {
      progEl.value = progress;
      if (progress % 10 === 0) {
        log(`Parsing UF2... ${progress}%`);
      }
    });
    log(`Blocks: ${uf2.blocks.length}`);
    log(`Erase ranges: ${uf2.ranges.length}`);
    flashBtn.disabled = false;
  } catch (err) {
    uf2 = null;
    flashBtn.disabled = true;
    log("ERROR: " + err.message);
  }
};

document.getElementById("flash").onclick = async () => {
  if (!uf2) return;

  try {
    log("Request device...");
    const dev = await navigator.usb.requestDevice({
      filters: [
        { vendorId: VID, productId: 0x0003 },
        { vendorId: VID }
      ]
    });

    await dev.open();
    if (!dev.configuration) await dev.selectConfiguration(1);

    const iface = findIface(dev.configuration);
    if (!iface) throw new Error("No vendor interface found.");
    log(`Using interface ${iface.iface}, endpoints out=${iface.out} in=${iface.in}`);

    const pico = new PicoTool(dev, iface.iface, iface.out, iface.in);

    log("Open + reset");
    await pico.open();
    await pico.reset();

    log("Exclusive access");
    try {
      await pico.exclusiveAccess(1);
    } catch (err) {
      log(`Exclusive access failed (${err.message}); continuing...`);
    }

    log("Exit XIP");
    await pico.exitXip();

    if (eraseToggle && eraseToggle.checked) {
      setProgressMode("progress-erase");
      const totalEraseSectors = uf2.ranges.reduce(
        (sum, r) => sum + Math.ceil((r.end - r.start) / SECTOR),
        0
      );
      let erasedSectors = 0;

      for (const r of uf2.ranges) {
        log(`Erase 0x${r.start.toString(16)} (${r.end - r.start} bytes)`);
        for (let addr = r.start; addr < r.end; addr += SECTOR) {
          await pico.flashErase(addr, SECTOR, 10000);
          erasedSectors += 1;
          const progress = Math.round((erasedSectors / totalEraseSectors) * 100);
          progEl.value = progress;
          if (erasedSectors % 32 === 0 || erasedSectors === totalEraseSectors) {
            log(`Erase progress: ${progress}%`);
          }
          if ((addr - r.start) % (SECTOR * 64) === 0) await tick();
        }
      }
    } else {
      log("Erase skipped.");
    }

    setProgressMode("progress-write");
    let i = 0;
    for (const b of uf2.blocks) {
      i++;
      const progress = Math.round((i / uf2.blocks.length) * 100);
      progEl.value = progress;
      if (i % 256 === 0 || i === uf2.blocks.length) {
        log(`Write progress: ${progress}%`);
      }
      await pico.write(b.addr, b.data);
      if (i % 32 === 0) await tick();
    }

    log("Reboot");
    try {
      await pico.reboot(0, PicoTool.SRAM_END, 250);
      log("Done.");
    } catch (err) {
      log(`Reboot failed (${err.message}). Unplug/replug to reboot.`);
    }

    await pico.close();
  } catch (e) {
    log("ERROR: " + e.message);
  }
};

async function parseUF2(buf, onProgress) {
  if (buf.byteLength % 512) throw new Error("Bad UF2 size");

  const dv = new DataView(buf);
  const blocks = [];
  const ranges = [];
  const totalBlocks = buf.byteLength / 512;
  let lastProgress = -1;

  for (let o = 0, idx = 0; o < buf.byteLength; o += 512, idx += 1) {
    if (dv.getUint32(o, true) !== UF2_MAGIC) throw new Error("Bad UF2 magic");
    if (dv.getUint32(o + 4, true) !== UF2_MAGIC2) throw new Error("Bad UF2 magic2");
    if (dv.getUint32(o + 508, true) !== UF2_END) throw new Error("Bad UF2 end magic");

    const flags = dv.getUint32(o + 8, true);
    if (flags & UF2_FLAG_NOFLASH) continue;

    let addr = dv.getUint32(o + 12, true);
    const size = dv.getUint32(o + 16, true);
    if (size <= 0 || size > 476) throw new Error("Invalid UF2 payload size");

    if (addr < FLASH_BASE) addr += FLASH_BASE;

    blocks.push({
      addr,
      data: buf.slice(o + 32, o + 32 + size)
    });

    const start = addr & ~(SECTOR - 1);
    const end = (addr + size + SECTOR - 1) & ~(SECTOR - 1);
    ranges.push({ start, end });

    const progress = Math.floor(((idx + 1) / totalBlocks) * 100);
    if (progress !== lastProgress) {
      lastProgress = progress;
      if (onProgress) onProgress(progress);
    }
    if ((o & 0x7fff) === 0) await tick();
  }

  blocks.sort((a, b) => a.addr - b.addr);

  ranges.sort((a, b) => a.start - b.start);
  const merged = [];
  for (const r of ranges) {
    const last = merged[merged.length - 1];
    if (last && r.start <= last.end) {
      last.end = Math.max(last.end, r.end);
    } else {
      merged.push({ start: r.start, end: r.end });
    }
  }

  return { blocks, ranges: merged };
}

function findIface(cfg) {
  const preferredIndex = cfg.interfaces.length <= 1 ? 0 : 1;
  const preferred = cfg.interfaces[preferredIndex];
  if (preferred) {
    const alt = preferred.alternates[0];
    if (alt && alt.interfaceClass === 0xff) {
      const o = alt.endpoints.find(e => e.direction === "out");
      const n = alt.endpoints.find(e => e.direction === "in");
      if (o && n) {
        return { iface: preferred.interfaceNumber, out: o.endpointNumber, in: n.endpointNumber };
      }
    }
  }

  for (const i of cfg.interfaces) {
    for (const a of i.alternates) {
      if (a.interfaceClass !== 0xff) continue;
      const o = a.endpoints.find(e => e.direction === "out");
      const n = a.endpoints.find(e => e.direction === "in");
      if (o && n) {
        return { iface: i.interfaceNumber, out: o.endpointNumber, in: n.endpointNumber };
      }
    }
  }
  return null;
}

async function tick() {
  return new Promise(r => setTimeout(r, 0));
}

function withTimeout(promise, ms, label) {
  let timer;
  const timeout = new Promise((_, reject) => {
    timer = setTimeout(() => {
      reject(new Error(`${label} timed out after ${ms}ms`));
    }, ms);
  });

  return Promise.race([promise, timeout]).finally(() => clearTimeout(timer));
}

class PicoTool {
  static SRAM_END = 0x20042000;

  constructor(device, iface, outEndpoint, inEndpoint) {
    this.device = device;
    this.iface = iface;
    this.outEndpoint = outEndpoint;
    this.inEndpoint = inEndpoint;
    this.token = 1;
  }

  async open() {
    await this.device.claimInterface(this.iface);
  }

  async close() {
    await this.device.close();
  }

  async reset() {
    await withTimeout(this.device.controlTransferOut({
      requestType: "vendor",
      recipient: "interface",
      request: 0x41,
      value: 0x00,
      index: this.iface
    }), 3000, "controlTransferOut");
  }

  async exclusiveAccess(enabled) {
    const cmd = new ArrayBuffer(1);
    new DataView(cmd).setUint8(0, enabled ? 1 : 0);
    await this.runCmd(CMD_EXCLUSIVE, cmd);
  }

  async reboot(pc, sp, delayMs) {
    const cmd = new ArrayBuffer(12);
    const view = new DataView(cmd);
    view.setUint32(0, pc, true);
    view.setUint32(4, sp, true);
    view.setUint32(8, delayMs, true);
    await this.runCmd(CMD_REBOOT, cmd);
  }

  async flashErase(addr, size, timeoutMs) {
    const cmd = new ArrayBuffer(8);
    const view = new DataView(cmd);
    view.setUint32(0, addr, true);
    view.setUint32(4, size, true);
    await this.runCmd(CMD_ERASE, cmd, undefined, timeoutMs);
  }

  async write(addr, data) {
    const cmd = new ArrayBuffer(8);
    const view = new DataView(cmd);
    view.setUint32(0, addr, true);
    view.setUint32(4, data.byteLength, true);
    await this.runCmd(CMD_WRITE, cmd, data);
  }

  async exitXip() {
    await this.runCmd(CMD_EXIT_XIP);
  }

  async runCmd(cmdId, cmdData, transferLengthOrData, timeoutMs = 3000) {
    const cmd = new ArrayBuffer(32);
    const view = new DataView(cmd);

    view.setUint32(0, PICOBOOT_MAGIC, true);
    view.setUint32(4, this.token++, true);
    view.setUint8(8, cmdId);
    view.setUint8(9, cmdData ? cmdData.byteLength : 0);
    view.setUint16(10, 0x0000, true);

    if (transferLengthOrData === undefined) {
      view.setUint32(12, 0, true);
    } else if (typeof transferLengthOrData === "number") {
      view.setUint32(12, transferLengthOrData, true);
    } else {
      view.setUint32(12, transferLengthOrData.byteLength, true);
    }

    if (cmdData) {
      const src = new Uint8Array(cmdData);
      new Uint8Array(cmd, 16, src.length).set(src);
    }

    await withTimeout(this.device.transferOut(this.outEndpoint, cmd), timeoutMs, "transferOut(cmd)");

    let transferInResult;
    if (transferLengthOrData !== undefined) {
      if (cmdId & 0x80) {
        transferInResult = await withTimeout(
          this.device.transferIn(this.inEndpoint, transferLengthOrData),
          timeoutMs,
          "transferIn(data)"
        );
      } else {
        await withTimeout(
          this.device.transferOut(this.outEndpoint, transferLengthOrData),
          timeoutMs,
          "transferOut(data)"
        );
      }
    }

    if (cmdId & 0x80) {
      await withTimeout(
        this.device.transferOut(this.outEndpoint, new ArrayBuffer(1)),
        timeoutMs,
        "transferOut(ack)"
      );
    } else {
      transferInResult = await withTimeout(
        this.device.transferIn(this.inEndpoint, 1),
        timeoutMs,
        "transferIn(status)"
      );
    }

    return transferInResult ? new Uint8Array(transferInResult.data.buffer) : null;
  }
}
</script>

</body>
</html>
